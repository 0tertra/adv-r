\chapter{The package development cycle}

The package development cycle describes the sequence of operations that
you use when developing a package. You probably already have a sequence
of operations that you're comfortable with when developing a single file
of R code. It might be:

\begin{itemize}
\item
  Try something out on the command line.
\item
  Modify it until it works and then copy and paste the command into an R
  file.
\item
  Every now and then restart R and source in the R file to make sure you
  haven't missed anything.
\end{itemize}

Or:

\begin{itemize}
\item
  Write all your functions in an R file.
\item
  \texttt{source()} the file into your current session.
\item
  Interactively try out the functions and see if they return the correct
  results.
\item
  Repeat the above steps until the functions work the way you expect.
\end{itemize}

Things get a bit harder when you're working on a package, because you
have multiple R files. You might also be a little bit more worried about
checking that your functions work, not only now, on your computer, but
also in the future and on other computers.

The sections below describe useful practices for developing packages,
where you might have many R files, and you are also thinking about
documentation and testing. Both are supported by the \texttt{devtools}
function \texttt{dev\_mode}, which helps to keep your production and
development packages separate.

\section{Dev mode}

When you're developing packages, typically you are developing them
because you're using them - and that easily leads to confusion. When
you're doing data analysis, you want to use a stable version but when
you are developing code, you want to make sure that you can test changes
that you have made.

The \texttt{dev\_mode()} function makes it easier to manage the
distinction between stable and development versions of a package. During
development, the function \texttt{dev\_mode()} will install the package
in a special library that is not part of the default library path. Here,
you can install and test new packages. During analysis, you keep
\texttt{dev\_mode()} off and R won't find the development packages:

\begin{verbatim}
# During development
dev_mode()
install("mypackage")
library(mypackage) # uses the development version

# Fresh R session
library(mypackage) # uses the released package you've installed previously
\end{verbatim}

\section{Key functions}

The three functions that you'll use most often are:

\begin{itemize}
\item
  \texttt{load\_all("pkg")}, which loads code, data, and C files. These
  are loaded into a non-global environment to avoid conflicts and so all
  functions can easily be removed. By default \texttt{load\_all} will
  only load changed files to save time: if you want to reload everything
  from scratch, run \texttt{load\_all("pkg", T)}
\item
  \texttt{test("pkg")} runs all tests in \texttt{inst/tests/} and
  reports the results.
\item
  \texttt{document("pkg")} runs \texttt{roxygen} on the package to
  update all documentation.
\end{itemize}

This makes the development process very easy. After you've modified the
code, you run \texttt{load\_all("pkg")} to load it in to R. You can
explore it interactively from the command line, or type
\texttt{test("pkg")} to run all your automated tests.

Some GUIs have integrated support for these functions. RStudio provides
the build menu, which allows you to easily run \texttt{load\_all} with a
single key press (Ctrl + Shift + L at time of writing). ESS?

The following sections describe how you might combine these functions
into a process.

\section{Development cycles}

It's useful to distinguish between exploratory programming and
confirmatory programming (in the same sense as exploratory and
confirmatory data analysis), because the development cycle differs in
several important ways.

\subsection{Confirmatory programming}

Confirmatory programming happens when you know what you need to do and
what the results of your changes will be (new feature X appears or known
bug Y disappears); you just need to figure out the way to do it.
Confirmatory programming is also known as
\href{http://en.wikipedia.org/wiki/Test-driven_development}{test driven
development} (TDD), a development style that grew out of
\href{extreme-programming}{extreme programming}. The basic idea is that,
before you implement any new feature or fix a known bug, you should:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write an automated test and run \texttt{test()} to make sure the test
  fails (so you know you've captured the bug correctly).
\item
  Modify code to fix the bug or implement the new feature.
\item
  Run \texttt{test(pkg)} to reload the package and re-run the tests.
\item
  Repeat 2--3 until all tests pass.
\item
  Update documentation comments, run \texttt{document()}, and update
  \texttt{NEWS}.
\end{enumerate}

For this paradigm, you might also want to use
\texttt{testthat::auto\_test()}, which will watch your tests and code
and will automatically rerun your tests when either changes. This allows
you to skip step three: you just modify your code and watch to see if
the tests pass or fail.

\subsection{Exploratory programming}

Exploratory programming is the complement of confirmatory programming,
when you have some idea of what you want to achieve, but you're not sure
about the details. You're not sure what the functions should look like,
what arguments they should have and what they should return. You may not
even be sure how you are going to break down the problem into pieces. In
exploratory programming, you're exploring the solution space by writing
functions and you need the freedom to rewrite large chunks of the code
as you understand the problem domain better.

The exploratory programming cycle is similar to confirmatory, but it's
not usually worth writing the tests before writing the code, because the
interface will change so much:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Edit code and reload with \texttt{load\_all()}.
\item
  Test interactively.
\item
  Repeat 1--2 until code works.
\item
  Write automated tests and \texttt{test()}.
\item
  Update documentation comments, run \texttt{document()}, and update
  \texttt{NEWS}
\end{enumerate}

The automated tests are still vitally important because they are what
will prevent your code from failing silently in the future.
