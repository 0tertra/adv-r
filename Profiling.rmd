---
title: Profiling and benchmarking
layout: default
---

```{r, echo = FALSE}
source("code/microbenchmark.r")
```

# Profiling and performance optimisation {#profiling}

> "We should forget about small efficiencies, say about 97% of the time:
> premature optimization is the root of all evil" --- Donald Knuth.

The key idea in this chapter can be summed up simply: "Find out what's then make it fast".  The first part of this chapter introduces you to tools to help understand what makes your code slow. The second part introduces you to some general tools for making your code faster.

Unfortunately optimisations are typically tightly coupled with the problem. It's hard to give give advice that will work in every situation, but I'll do my best. I include some general techniques, and so

Explore

Your code should be correct, maintainable and fast. Notice that speed comes last - if your function is incorrect or unmaintainable (i.e. will eventually become incorrect) it doesn't matter if it's fast. As computers get faster and R is optimised, your code will get faster all by itself. Your code is never going to automatically become correct or elegant if it is not already.

When making code faster be careful not to make it incorrect.


Like javascript, the vast majority of R code is poorly written and slow. This sounds bad but it's actually a positive! There's no point in optimising code until it's actually a bottleneck - most R code should be incredibly inefficient because even inefficient code is usually fast enough. If most R code was efficient, it would be a strong signal that R programmers are prematurely optimising, spend time making their code faster instead of solving real problems. Additionally, most people writing R code are not programmers. Many of them don't have any formal training in programming or computer science, but are using R because it helps them solve their data analysis problems.

This means that the vast majority of R code can be re-written in R to be more efficient. This often means vectorising code, or avoiding some of the most obvious traps discussed in the [R inferno] (http://www.burns-stat.com/documents/books/the-r-inferno/). There are also other strategies like caching/memoisation that trade space for time. Otherwise, a basic knowledge of data structures and algorithms can help come up with alternative strategies.

This applies not only to packages, but also to base R code. The focus on R code has been making a useful tool, not a blazingly fast programming language. There is huge room for improvement, and base R is only going to get faster over time.

That said, sometimes there are times where you need to make your code faster: spending several hours of your day might save days of computing time for others. The aim of this chapter is to give you the skills to figure out why your code is slow, what you can do to improve it, and ensure that you don't accidentally make it slow again in the future.  You may already be familiar with `system.time`, which tells you how long a block of code takes to run. This is a useful building block, but is a crude tool.

Along the way, you'll also learn about the most common causes of poor performance in R, and how to address them. Sometimes there's no way to improve performance within R, and you'll need to use C++, the topic of [Rcpp](#rcpp).

Having a good test suite is important when tuning the performance of your code: you don't want to make your code fast at the expense of making it incorrect. We won't discuss testing any further in this chapter, but we strongly recommend having a good set of test cases written before you begin optimisation.

Additionally, most people writing R code are not programmers. Many of don't have any formal training in programming or computer science, but are using R because it helps them solve their data analysis problems. This means that the vast majority of R code can be re-written in R to be more efficient. This often means vectorising code, or avoiding some of the most obvious traps discussed later in this chapter. There are also other strategies like caching/memoisation that trade space for time. Otherwise, a basic knowledge of data structures and algorithms can help come up with alternative strategies.

[Mature optimisation](http://carlos.bueno.org/optimization/mature-optimization.pdf) (PDF)

A recurring theme throughout this part of the book is the importance of differentiating between absolute and relative speed, and fast vs fast enough. First, whenever you compare the speed of two approaches to a problem, be very wary of just looking at a relative differences. One approach may be 10x faster than another, but if that difference is between 1ms and 10ms, it's unlikely to have any real impact. You also need to think about the costs of modifying your code. For example, if it takes you an hour to implement a change that makes you code 10x faster, saving 9 s each run, then you'll have to run at least 400 times before you'll see a net benefit.  At the end of the day, what you want is code that's fast enough to not be a bottleneck, not code that is fast in any absolute sense.  Be careful that you don't spend hours to save seconds.

##### Prereqs

`install_github("hadley/lineprof")`

## Understanding performance

R provides a built in tool for profiling: `Rprof`. When active, this records the current call stack to disk every `interval` seconds. This provides a fine grained report showing how long each function takes. The function `summaryRprof` provides a way to turn this list of call stacks into useful information. But I don't think it's terribly useful, because it makes it hard to see the entire structure of the program at once. Instead, we'll use the `profr` package, which turns the call stack into a data.frame that is easier to manipulate and visualise.

Example showing how to use profr.

Sample pictures.

Other tools:
* https://github.com/ltierney/Rpkg-proftools - show flamegraph and call graph

## Improving performance

* use better tools
* alternative algorithms
* trade space for time
* write in C++

## Use better tools


### Other people's code

One of the easiest ways to speed up your code is to find someone who's already done it! Good idea to search for CRAN packages.

    RppGSL, RcppEigen, RcppArmadillo

Stackoverflow can be a useful place to ask.

* If you want to find if a vector contains a single value, `any(x == 10)`
  is much faster than `10 %in% x` or `is.element(10, x).

* `apply()` is always slower than a specialised functions: be aware of
  `rowSums()`, `colSums()`, `rowMeans()`, and `colMeans()`.

* Be aware of the most efficient ways to convert continuous to categorical
  values (`findInterval()`) and to re-name categorical values (character
  subsetting).

* Work with the simplest object possible. Data frames are particularly
  expensive because modifying any value in a data frame will copy the
  entire data frame. Lists and matrices don't suffer from this problem so
  can be much faster. Instead of splitting a data frame, split a vector of
  indices and then use to index into the data frame when needed.

* `ifelse()` is slow, particularly if you are testing multiple conditions.
  One trick to get around this is to assign a unique number to each combination
  of logical values by using binary. If `x`, `y` and `z` are logical variables
  then `x + 2 * y + 4 * z` will assume a unique number between 1 and 8 to each
  combination of TRUE and FALSE values. See http://rpubs.com/wch/8107 for other
  approaches.

* Writing to a `textConnection()` is very slow, use a temporary file on disk
  instead. (More details at http://rpubs.com/wch/13698).

* If you're fitting many linear models, `lm()` is quite slow. Use
  `model = FALSE` to avoid copying the input data in. Look at the biglm
  package. Try RcppArmadillo::fastLm

## Case study: Lots of t-tests

Vectorisation is a powerful tool. But it's not always possible to apply it directly, and you may need to understand the underlying method. The following case study explores how to make many t-tests faster, following "Computing thousands of test statistics simultaneously in R" by Holger Schwender and Tina MÃ¼ller in http://stat-computing.org/newsletter/issues/scgn-18-1.pdf.

```{r, cache = TRUE}
m <- 10000
n <- 50
X <- matrix(rnorm(m * n, 10, 3), m)
cl <- rep(0:1, e = n / 2)

system.time(for(i in 1:m) t.test(X[i, ] ~ cl)$stat)
system.time(for(i in 1:m) t.test(X[i, cl == 0], X[i, cl== 1])$stat)

compT <- function(x, cl){
  t.test(x[cl == 0], x[cl == 1])$stat
}
system.time(apply(X, 1, compT, cl = cl))

rowtstat <- function(X, cl){
  X0 <- X[, cl == 0]
  m0 <- rowMeans(X0)
  n0 <- sum(cl == 0)
  s0 <- rowSums((X0 - m0) ^ 2)
  s0 <- s0 / (n0 * (n0 - 1))

  X1 <- X[, cl == 1]
  m1 <- rowMeans(X1)
  n1 <- sum(cl)
  s1 <- rowSums((X1 - m1) ^ 2)
  s1 <- s1 / (n1 * (n1 - 1))

  (m0 - m1) / sqrt(s0 + s1)
}
system.time(rowtstat(X, cl))

rowtstat <- function(X, cl){
  t_stat <- function(X) {
    m <- rowMeans(X)
    n <- length(m)

    var <- rowSums((X - m) ^ 2) / (n - 1)

    list(m = m, n = n, var = var)
  }

  g1 <- t_stat(X[, cl == 0])
  g2 <- t_stat(X[, cl == 1])

  pooled_se <- sqrt(g1$var / g1$n + g2$var / g1$n)
  (g1$m - g2$m) / pooled_se
}
system.time(rowtstat(X, cl))

```
## Case study speeding up bootstrap fits of linear model

The `lm()` function is a good example.

1.  `model.frame()` handles non-standard evaluation to create a single
    data frame containing all variables needed.

2.  `model.matrix()` converts a formula and a data frame to a matrix.

3.  `lm.fit()` performs the linear algebra

4.  The final results and combined with intermediate pieces to create
    an S3 object.

```{r}
fit_model <- function(df) {
  coef(lm(mpg ~ disp + wt + cyl, data = df))
}
boot <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}
system.time(replicate(1000, fit_model(boot(mtcars))))

library(lineprof)
l <- lineprof(replicate(1000, fit_model(boot(mtcars))))
shine(l)
```

```{r}
library(biglm)
library(RcppArmadillo)

mtcars$cyl <- factor(mtcars$cyl)
mtcars_m <- model.matrix(mpg ~ disp + wt + cyl, mtcars)

library(microbenchmark)
microbenchmark(
  mtcars_m <- model.matrix(mpg ~ disp + wt + cyl, mtcars),
  coef(lm(mpg ~ disp + wt + cyl, data = mtcars)),
  coef(lm.fit(mtcars_m, mtcars$mpg)),

  coef(fastLm(mpg ~ disp + wt + cyl, data = mtcars)),
  coef(fastLmPure(mtcars_m, mtcars$mpg))[, 1]
)
```

```{r, eval = FALSE}
data(diamonds, package = "ggplot2")
diamonds_m <- model.matrix(price ~ carat + color, diamonds)

library(microbenchmark)
microbenchmark(
  diamonds_m <- model.matrix(price ~ carat + color, diamonds),
  coef(lm(price ~ carat + color, diamonds)),
  coef(lm.fit(diamonds_m, diamonds$price)),

  coef(fastLm(price ~ carat + color, diamonds)),
  coef(fastLmPure(diamonds_m, diamonds$price))[, 1],
  times = 10
)
```

### Byte code compilation

R 2.13 introduced a new byte code compiler which can increase the speed of certain types of code 4-5 fold. This improvement is likely to get better in the future as the compiler implements more optimisations - this is an active area of research.

```{r}
library(compiler)
```

Using the compiler is an easy way to get speed ups - it's easy to use, and if it doesn't work well for your function, then you haven't invested a lot of time in it, and so you haven't lost much. The following example shows the pure R version of `lapply()` from [functionals](#lapply). Compiling it gives a considerable speedup, although it's still not quite as fast as the C version provided by base R.

```{r}
lapply2 <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}

lapply2_c <- cmpfun(lapply2)

x <- list(1:10, letters, c(F, T), NULL)
microbenchmark(
  lapply2(x, is.null),
  lapply2_c(x, is.null),
  lapply(x, is.null)
)
```

This is a relatively good example for byte code compiling. In most cases you're more like to get a 10-40% speedup. This example optimises well because it uses a for-loop, something that is generally rare in R.

All base R functions are byte code compiled by default.

## Trade space for time

`readRDS`, `saveRDS`

Caching packages

A special case of caching is memoisation.

## Brainstorming

Most important step is to brainstorm as many possible alternative approaches.

Can often recreate slow general purpose functions to fast special purpose functions. Can easily access faster languages.

Good to have a variety of approaches to call upon.

* Read blogs
* Algorithm/data structure courses (https://www.coursera.org/course/algs4partI)
* Book
* Read R code

We introduce a few at a high-level in the Rcpp chapter.
